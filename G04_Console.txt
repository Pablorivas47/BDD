-- //////////////////////// TPE BDD  ////////////////////////

-- TABLA Cliente:
ALTER TABLE Cliente ADD CONSTRAINT ck_saldo_no_negativo
CHECK (saldo >= 0);
-- Justificación: Este CHECK se asegura de que ningún cliente tenga un saldo negativo. El saldo de la cuenta del
-- cliente debe mantenerse siempre el positivo ya que no se aceptan deudas.

-- TABLA Comprobante:
ALTER TABLE Comprobante ADD CONSTRAINT ck_fecha_vencimiento
CHECK (fecha_vencimiento >= fecha);
-- Justificación: Este CHECK garantiza que la fecha de vencimiento de un comprobante sea igual o posterior a la
-- fecha de emisión. Que la fecha de vencimiento de un comprobante sea mayor a la fecha en la que se crea es incoherente.

ALTER TABLE Comprobante ADD CONSTRAINT ck_importe_positivo
CHECK (importe >= 0);
-- Justificación: Este CHECK asegura que el importe de un comprobante debe ser un valor positivo o cero, dejando
-- en claro que no se pueden crear comprobantes con importes negativos.

-- TABLA Equipo:
ALTER TABLE Equipo ADD CONSTRAINT ck_fecha_limite
CHECK (fecha_alta < fecha_baja);
-- Justificación: Este CHECK se garantiza de que la fecha de baja de un equipo ocurra después de su fecha de alta.
-- Esto asegura que los períodos de uso de los equipos sean válidos, evitando situaciones donde el equipo esté
-- dado de baja antes de haber sido dado de alta.

-- TABLA LineaComprobante:
ALTER TABLE LineaComprobante ADD CONSTRAINT ck_cantidad_no_negativa
CHECK (cantidad > 0);
-- Justificación: Este CHECK asegura que la cantidad de un producto o servicio en una línea de comprobante sea siempre
-- positiva. Registrar una cantidad negativa sería incoherente ya que estamos hablando de una compra real de productos.

ALTER TABLE LineaComprobante ADD CONSTRAINT ck_importe_positivo
CHECK (importe > 0);
-- Justificación: Este CHECK asegura que el importe asociado a cada línea de comprobante sea positivo.
-- Un valor negativo en el importe representa un error de cálculo.

ALTER TABLE Servicio ADD CONSTRAINT ck_costo_positivo
CHECK (costo >= 0);
-- Justificación: Este CHECK asegura que el costo de un servicio no puede ser negativo. Esto se realiza para garantizar
-- que el valor asignado a los servicios sea positivo, evitando así el ingreso erróneo	de valores.

ALTER TABLE Turno ADD CONSTRAINT ck_fecha_limite
CHECK (desde < hasta);
-- Justificación: Este CHECK asegura que un turno tenga una duración válida, es decir, que la hora de inicio sea antes
-- que la de finalización. Que un turno termine antes de comenzar es incoherente.

ALTER TABLE Turno ADD CONSTRAINT ck_dinero_positivo
CHECK (dinero_inicio > 0 AND dinero_fin > 0);
-- Justificación: Este CHECK garantiza que tanto el dinero al inicio como al final del turno sean valores positivos.
-- Esto previene inconsistencias, y asegura que por más que se realicen gastos el dinero final nunca sea negativo, por lo que no se podría realizar una compra sin tener el dinero suficiente.

ALTER TABLE Turno ADD CONSTRAINT ck_dinero_orden
CHECK (dinero_inicio > dinero_fin);
-- Justificación: Este CHECK asegura que el dinero al inicio del turno sea mayor que el dinero al final, lo que indica
-- un consumo de recursos o gastos durante el turno.

-- ---------------- Insert y Delete tuplas ----------------

-- //////////////////////// DELETE DE TABLAS  ////////////////////////
DELETE FROM Persona
WHERE id_persona = 3;

DELETE FROM Cliente
WHERE id_cliente = 1;

DELETE FROM Comprobante
WHERE id_comp = 102;

DELETE FROM lineacomprobante
WHERE id_tcomp = 1;

UPDATE Persona
SET id_persona = 2
WHERE id_persona = 3;

-- //////////////////////// 1-a Tuplas para check  ////////////////////////

-- INSERT que cumple la restricción -> CUMPLE con el Alter table del inciso 1-a
INSERT INTO Persona (id_persona, tipo, tipodoc, nrodoc, nombre, apellido, fecha_nacimiento, fecha_alta, fecha_baja, activo, mail)
VALUES (1, 'Física', 'DNI', '87654321', 'María', 'Gómez', '1985-05-15', '2024-01-01', '2024-07-15', false, 'maria.gomez@mail.com');

-- INSERT que cumple la restricción porque la persona está activa
INSERT INTO Persona (id_persona, tipo, tipodoc, nrodoc, nombre, apellido, fecha_nacimiento, fecha_alta, fecha_baja, activo, mail)
VALUES (2, 'Física', 'DNI', '11223344', 'Carlos', 'López', '1980-10-10', '2024-01-01', NULL, true, 'carlos.lopez@mail.com');

-- INSERT que no cumple la restricción -> NO CUMPLE con el Alter table del inciso 1-a
INSERT INTO Persona (id_persona, tipo, tipodoc, nrodoc, nombre, apellido, fecha_nacimiento, fecha_alta, fecha_baja, activo, mail)
VALUES (3, 'Física', 'DNI', '12345678', 'Juan', 'Pérez', '1990-01-01', '2024-01-01', '2024-04-01', false, 'juan.perez@mail.com');

SELECT p.*
FROM unc_249828.persona p;

-- ---------------- Inciso 1) a ----------------

ALTER TABLE Persona
ADD CONSTRAINT chk_fecha_baja
CHECK (
    (activo = true AND fecha_baja IS NULL) OR
    (activo = false AND fecha_baja IS NOT NULL AND fecha_baja >= fecha_alta + INTERVAL '6 months')
);




-- //////////////////////// 1-b Tuplas para check  ////////////////////////

-- Insert en LineaComprobante
INSERT INTO LineaComprobante (nro_linea, id_comp, id_tcomp,descripcion, cantidad, importe, id_servicio) VALUES
(1, 101, 1, 'descripcion1',10, 50,null);

INSERT INTO LineaComprobante (nro_linea, id_comp, id_tcomp,descripcion, cantidad, importe, id_servicio) VALUES
(2, 101, 1, 'descripcion2',20, 30,null);

INSERT INTO LineaComprobante (nro_linea, id_comp, id_tcomp,descripcion, cantidad, importe, id_servicio) VALUES
(3, 101, 1, 'descripcion3',20, 20,null);

-- Insert en Comprobante que cumple con la suma de LineaComprobante
INSERT INTO Comprobante (id_comp, id_tcomp,fecha, comentario,estado, fecha_vencimiento, id_turno, importe, id_cliente, id_lugar ) VALUES
(104, 1, '1980-10-10', 'comentario ','', '1980-10-10',  null,  80, 1, 1);

INSERT INTO Comprobante (id_comp, id_tcomp,fecha, comentario,estado, fecha_vencimiento, id_turno, importe, id_cliente, id_lugar ) VALUES
(103, 1, '1980-10-10', 'comentario ','', '1980-10-10',  null,  0, 1, 1);

INSERT INTO tipocomprobante (id_tcomp, nombre, tipo ) VALUES
(1, 'Pablo', '');

INSERT INTO cliente (id_cliente, saldo ) VALUES
(1, 20.00);

INSERT INTO cliente (id_cliente, saldo ) VALUES
(2, 20.00);

INSERT INTO Lugar (id_lugar, nombre ) VALUES
(1, 'Pablo');

UPDATE comprobante
SET importe = 550
WHERE id_tcomp = 1 and id_comp = 3;

UPDATE lineacomprobante
SET importe = 3500
WHERE id_tcomp = 1 and id_comp = 3;

SELECT t.*
FROM unc_249828.comprobante t;

SELECT lc.*
FROM unc_249828.lineacomprobante lc;

DELETE FROM lineacomprobante
WHERE id_comp = 101 and nro_linea = 1;

-- ---------------- Inciso 1) b ----------------
-- Esta consulta te devuelve todos los comprobantes donde el importe no coincide con la suma de los importes
-- de las líneas asociadas. COALESCE se usa para manejar el caso en que no haya líneas asociadas
-- (en cuyo caso, el total es 0).

SELECT c.id_comp, c.id_tcomp, c.importe
FROM Comprobante c
LEFT JOIN LineaComprobante lc Using(id_comp,id_tcomp)
GROUP BY c.id_comp, c.id_tcomp, c.importe
HAVING c.importe = COALESCE(SUM(lc.importe), 0);

--////////// Comprobante //////////

CREATE OR REPLACE FUNCTION func_verificar_importe_comprobante()
RETURNS TRIGGER AS $$
DECLARE
    total_importe NUMERIC;
BEGIN
    -- Calcular la suma de los importes de las líneas del comprobante
    SELECT COALESCE(SUM(lc.importe), 0) INTO total_importe
    FROM LineaComprobante lc
    WHERE lc.id_comp = NEW.id_comp AND lc.id_tcomp = NEW.id_tcomp;

    IF tg_op = 'UPDATE' THEN
        -- Verificar si el importe del comprobante coincide con el total
        IF NEW.importe <> total_importe THEN
            RAISE EXCEPTION 'El i mporte del comprobante debe ser igual a la suma de los importes de las líneas. Se esperaba %. Se recibió %.', total_importe, NEW.importe;
        END IF;
    END if;

    IF tg_op = 'INSERT' THEN
        -- Verificar si el total_importe es 0
        IF total_importe = 0 AND NEW.importe <> 0 THEN
            RAISE EXCEPTION 'El total de importes de las líneas es 0. No se puede crear o actualizar el comprobante.';
        END IF;
    END if;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE TRIGGER trigger_verificar_importe_insert
AFTER INSERT OR UPDATE ON Comprobante
FOR EACH ROW
EXECUTE FUNCTION func_verificar_importe_comprobante();

--////////// Linea comprobante //////////

CREATE OR REPLACE FUNCTION func_actualizar_importe_comprobante()
RETURNS TRIGGER AS $$
DECLARE
    total_importe NUMERIC;
    v_id_comp BIGINT;
    v_id_tcomp INT;
BEGIN
    -- Definir los valores de id_comp e id_tcomp basados en la operación (INSERT, UPDATE, DELETE)
    IF (TG_OP = 'DELETE') THEN
        v_id_comp := OLD.id_comp;
        v_id_tcomp := OLD.id_tcomp;
    ELSE
        v_id_comp := NEW.id_comp;
        v_id_tcomp := NEW.id_tcomp;
    END IF;

    -- Calcular la suma total de importes de las líneas del comprobante
    SELECT COALESCE(SUM(importe), 0) INTO total_importe
    FROM LineaComprobante
    WHERE id_comp = v_id_comp AND id_tcomp = v_id_tcomp;

    -- Actualizar el importe del comprobante
    UPDATE Comprobante
    SET importe = total_importe
    WHERE id_comp = v_id_comp AND id_tcomp = v_id_tcomp;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE TRIGGER  trigger_actualizar_importe
AFTER INSERT OR UPDATE OR DELETE ON LineaComprobante
FOR EACH ROW
EXECUTE FUNCTION func_actualizar_importe_comprobante();

-- ---------------- Inciso 1) c ----------------
CREATE OR REPLACE FUNCTION verificar_ip_unica()
RETURNS TRIGGER AS $$
BEGIN
    -- Verificar si la IP ya está asignada a otro cliente
     IF EXISTS (SELECT 1
         FROM Equipo
         WHERE ip = NEW.ip AND id_cliente <> NEW.id_cliente
     ) THEN
         RAISE EXCEPTION 'La IP % ya está asignada a otro cliente.', NEW.ip;
     END IF;

     RETURN NEW;
 END;
 $$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_verificar_ip
BEFORE INSERT OR UPDATE ON Equipo
FOR EACH ROW
EXECUTE FUNCTION verificar_ip_unica();

-- //////////////////////// 1-c Tuplas para check  ////////////////////////

--//testeo de insert
INSERT INTO equipo (id_equipo, nombre, mac, ip, id_cliente, fecha_alta)
VALUES(123, 'smartphone', '1234','2001',1, '2001-08-18');
--//equipo insertado//acepta
INSERT INTO equipo (id_equipo, nombre, mac, ip, id_cliente, fecha_alta)
VALUES(1234, 'smartphone', '1234','2001',2, '2001-08-18');
--//equipo a insertar con la misma IP//tira error

--//testeo de update
UPDATE equipo
SET ip = '2001'
WHERE id_equipo = 1234 and id_cliente = 2;
--//update//tira error
UPDATE equipo
SET ip = '2003'
WHERE id_equipo = 1234 and id_cliente = 2;
--//update//acepta

-- //////////////////////// 2-a  ////////////////////////
SELECT s.*
FROM unc_249828.servicio s;

DELETE FROM servicio
WHERE id_servicio = 1;

INSERT INTO servicio (id_servicio, nombre,periodico, costo, intervalo, tipo_intervalo, activo, id_cat)
VALUES
(1, 'Servicio de Internet 50MB', TRUE,5000, 1, 'mes',  TRUE,1);
INSERT INTO servicio (id_servicio, nombre,periodico, costo, intervalo, tipo_intervalo, activo, id_cat)
VALUES
(2, 'Mantenimiento de Equipo', TRUE, 10000, 3, 'mes',  TRUE,2);


SELECT c.*
FROM unc_249828.categoria c;

INSERT INTO categoria (id_cat, nombre)
VALUES
(1, 'Categoria 1'),
(2, 'Categoria 2'),
(3, 'Categoria 3');

SELECT e.*
FROM unc_249828.equipo e;

INSERT INTO Equipo (id_equipo, id_cliente, id_servicio, nombre, mac, ip, ap, fecha_alta, fecha_baja, tipo_conexion, tipo_asignacion)
VALUES
(1, 1, 1, 'Router de Maria Gomez', 'AA:BB:CC:DD:EE:FF', '192.168.1.10', 'AP1', '2024-01-01', NULL, 'Fibra óptica', 'Manual'),
(2, 2, 2, 'Servidor de Carlos Lopez', 'FF:EE:DD:CC:BB:AA', '192.168.1.11', 'AP2', '2024-01-01', NULL, 'Cable Ethernet', 'Automático');


SELECT p.*
FROM unc_249828.persona p;

INSERT INTO Persona (id_persona, tipo, tipodoc, nrodoc, nombre, apellido, fecha_nacimiento, fecha_alta, fecha_baja, activo, mail, telef_area, telef_numero)
VALUES
(1, 'Física', 'DNI', '876554321', 'Maria', 'Gomez', '1985-05-15', '2024-01-01', '2024-07-15', false, 'maria.gomez@mail.com', null,null),
(2, 'Física', 'DNI', '11223344', 'Carlos', 'Lopez', '1980-10-10', '2024-01-01', null, true, 'carlos.lopez@mail.com',null,null);


-- es para que se setee automaticamente el id del comprobante, sin tener que verificar cual falta
CREATE SEQUENCE comprobante_seq
    START WITH 1 -- Empieza desde 1
    INCREMENT BY 1 -- Incrementa de 1 en 1
    NO MAXVALUE; -- Sin límite máximo


CREATE OR REPLACE PROCEDURE generar_facturas_servicios(fecha_factura DATE)
LANGUAGE 'plpgsql' AS
$body$
DECLARE
    r_servicio RECORD;
    r_equipo RECORD;
    v_id_comp BIGINT;
    v_id_tcomp INT := 1; -- Asumimos un tipo de comprobante
    v_fecha TIMESTAMP := fecha_factura; -- Utilizamos la fecha pasada como parámetro
BEGIN
    -- Seleccionamos todos los servicios periódicos activos
    FOR r_servicio IN
        SELECT id_servicio, nombre, costo, intervalo, tipo_intervalo
        FROM Servicio
        WHERE periodico = TRUE AND activo = TRUE
    LOOP
        -- Para cada servicio periódico, buscamos los equipos asociados a clientes
        FOR r_equipo IN
            SELECT id_cliente, id_servicio
            FROM Equipo
            WHERE id_servicio = r_servicio.id_servicio AND id_cliente IS NOT NULL
        LOOP
            -- Generar ID único para el comprobante
            v_id_comp := nextval('comprobante_seq'); -- Verifica que la secuencia exista

            -- Insertar el comprobante inicialmente con importe = 0
            INSERT INTO Comprobante (id_comp,id_tcomp,fecha,comentario,estado,fecha_vencimiento,importe, id_cliente,id_lugar)
            VALUES (
                v_id_comp,
                v_id_tcomp,
                v_fecha, -- Utilizar la fecha pasada como parámetro
                'Factura generada automáticamente para el servicio ' || r_servicio.nombre,
                'Pendiente', -- Estado de la factura
                v_fecha + INTERVAL '1 month', -- Fecha de vencimiento (un mes después)
                0, -- Importante: Se inserta con importe 0
                r_equipo.id_cliente,
                NULL -- Asumimos que no hay lugar asociado
            );

            -- Insertar la línea del comprobante para el servicio facturado
            INSERT INTO LineaComprobante (nro_linea,id_comp, id_tcomp,descripcion,cantidad,importe,id_servicio)
            VALUES (
                1, -- Primera línea del comprobante
                v_id_comp,
                v_id_tcomp,
                'Servicio: ' || r_servicio.nombre || ', Periodo: ' || r_servicio.intervalo || ' ' || r_servicio.tipo_intervalo,
                1, -- Cantidad de servicios facturados
                r_servicio.costo, -- Importe del servicio
                r_servicio.id_servicio
            );
        END LOOP;
    END LOOP;

    -- Mensaje para indicar éxito en la generación de facturas
    RAISE NOTICE 'Facturas generadas correctamente para la fecha: %', v_fecha;
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'Error al generar las facturas: %', SQLERRM;
END;
$body$;

CALL generar_facturas_servicios(to_date('2024-10-01', 'yyyy-mm-dd'));

--////////////// Trigger sin el importe en 0, debido la restriccion del inciso 1-b /////////////////////
-- CREATE OR REPLACE PROCEDURE generar_facturas_servicios(fecha_factura DATE)
-- LANGUAGE 'plpgsql' AS
-- $body$
-- DECLARE
--     r_servicio RECORD;
--     r_equipo RECORD;
--     v_id_comp BIGINT;
--     v_id_tcomp INT := 1; -- Asumimos un tipo de comprobante
--     v_fecha TIMESTAMP := fecha_factura; -- Utilizamos la fecha pasada como parámetro
-- BEGIN
--     -- Seleccionamos todos los servicios periódicos activos
--     FOR r_servicio IN
--         SELECT id_servicio, nombre, costo, intervalo, tipo_intervalo
--         FROM Servicio
--         WHERE periodico = TRUE AND activo = TRUE
--     LOOP
--         -- Para cada servicio periódico, buscamos los equipos asociados a clientes
--         FOR r_equipo IN
--             SELECT id_cliente, id_servicio
--             FROM Equipo
--             WHERE id_servicio = r_servicio.id_servicio AND id_cliente IS NOT NULL
--         LOOP
--             -- Generar ID único para el comprobante
--             v_id_comp := nextval('comprobante_seq'); -- Verifica que la secuencia exista
--
--             -- Insertar el comprobante
--             INSERT INTO Comprobante (id_comp, id_tcomp, fecha, comentario, estado, fecha_vencimiento, importe, id_cliente, id_lugar)
--             VALUES (
--                 v_id_comp,
--                 v_id_tcomp,
--                 v_fecha, -- Utilizar la fecha pasada como parámetro
--                 'Factura generada automáticamente para el servicio ' || r_servicio.nombre,
--                 'Pendiente', -- Estado de la factura
--                 v_fecha + INTERVAL '1 month', -- Fecha de vencimiento (un mes después)
--                 r_servicio.costo, -- Importe del servicio
--                 r_equipo.id_cliente,
--                 NULL -- Asumimos que no hay lugar asociado
--             );
--
--             -- Insertar la línea del comprobante para el servicio facturado
--             INSERT INTO LineaComprobante (nro_linea, id_comp, id_tcomp, descripcion, cantidad, importe, id_servicio)
--             VALUES (
--                 1, -- Primera línea del comprobante
--                 v_id_comp,
--                 v_id_tcomp,
--                 'Servicio: ' || r_servicio.nombre || ', Periodo: ' || r_servicio.intervalo || ' ' || r_servicio.tipo_intervalo,
--                 1, -- Cantidad de servicios facturados
--                 r_servicio.costo, -- Importe del servicio
--                 r_servicio.id_servicio
--             );
--         END LOOP;
--     END LOOP;
--
--     -- Mensaje para indicar éxito en la generación de facturas
--     RAISE NOTICE 'Facturas generadas correctamente para la fecha: %', v_fecha;
-- EXCEPTION
--     WHEN OTHERS THEN
--         RAISE EXCEPTION 'Error al generar las facturas: %', SQLERRM;
-- END;
-- $body$;
--
-- -- Llamada al procedimiento con la fecha de facturación
-- CALL generar_facturas_servicios(to_date('2024-10-01', 'yyyy-mm-dd'));
